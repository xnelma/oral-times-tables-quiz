#ifndef OTTQ_20250829_1805_INCLUDE
#define OTTQ_20250829_1805_INCLUDE

#include <QLocale>
#include <QRegularExpression>
#include <ostream>
#include <exception>

namespace Tts {

struct LocaleDescriptor
{
    LocaleDescriptor() : language(QLocale::C), territory(QLocale::AnyTerritory)
    {
    }

    LocaleDescriptor(const QLocale::Language l, const QLocale::Territory t)
        : language(l), territory(t)
    {
    }

    LocaleDescriptor(const QLocale l)
        : language(l.language()), territory(l.territory())
    {
    }

    static Tts::LocaleDescriptor fromFileName(QString qmFileName)
    {
        // Regex for parsing the locale name from a translation resource file
        // name.
        // File names as generated by ldebug und lrelease are assumed to have
        // the form [prefix]xx.qm or [prefix]xx_XX.qm, with the prefix set
        // in qt_add_translations.
        // A third letter for language or territory is also possible, and the
        // delimiter could also be '-'.
        // The file name is assumed to not contain a script code.
        static const auto qmLocaleNameRegex =
            QRegularExpression("^.*([a-z]{2,3})([_-][A-Z]{2,3}){,1}.qm$");

        QRegularExpressionMatch match = qmLocaleNameRegex.match(qmFileName);
        if (!match.hasMatch())
            throw std::invalid_argument(
                "Invalid file name format. The expected format is xx.qm or"
                "xx_XX.qm/xx-XX.qm with a third x/X also being valid.");

        QLocale::Language language = QLocale::codeToLanguage(match.captured(1));
        QLocale::Territory territory = QLocale::AnyTerritory;
        if (match.lastCapturedIndex() >= 2) {
            // (This group starts with the delimiter; remove the first char.)
            territory = QLocale::codeToTerritory(match.captured(2).removeAt(0));
        }

        return LocaleDescriptor(language, territory);
    }

    static Tts::LocaleDescriptor fromResourcePath(const QString &qmPath)
    {
        if (qmPath.isEmpty() || qmPath.endsWith("/"))
            return LocaleDescriptor();

        // TODO if I don't use QFile for parsing, should I handle other
        // separators than "/"?
        QString fileName = *(--qmPath.split("/").end());
        return fromFileName(fileName);
    }

    bool operator==(const LocaleDescriptor &ld) const
    {
        return language == ld.language && territory == ld.territory;
    }
    bool operator<(const LocaleDescriptor &ld) const
    {
        return language < ld.language
            || (language == ld.language && territory < ld.territory);
    }
    // TODO unit test for operator<?
    friend std::ostream &operator<<(std::ostream &os,
                                    const LocaleDescriptor &ld)
    {
        auto languageStr = QLocale::languageToString(ld.language);
        auto territoryStr = QLocale::territoryToString(ld.territory);

        return os << "(" << languageStr.toUtf8().data() << ", "
                  << territoryStr.toUtf8().data() << ")";
    }

    QLocale::Language language;
    QLocale::Territory territory;
};

} // namespace Tts

#endif // OTTQ_20250829_1805_INCLUDE

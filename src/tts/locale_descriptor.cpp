#include "locale_descriptor.hpp"
#include <regex>
#include <exception>

Tts::LocaleDescriptor::LocaleDescriptor()
    : language(QLocale::C), territory(QLocale::AnyTerritory)
{
}

Tts::LocaleDescriptor::LocaleDescriptor(const QLocale::Language &l,
                                        const QLocale::Territory &t)
    : language(l), territory(t)
{
}

Tts::LocaleDescriptor::LocaleDescriptor(const QLocale &l)
    : language(l.language()), territory(l.territory())
{
}

auto Tts::LocaleDescriptor::fromFileName(const std::string &qmFileName)
    -> LocaleDescriptor
{
    // Regex for parsing the locale name from a translation resource file
    // name.
    // File names as generated by ldebug und lrelease are assumed to have
    // the form [prefix]xx.qm or [prefix]xx_XX.qm, with the prefix set
    // in qt_add_translations.
    // A third letter for language or territory is also possible, and the
    // delimiter could also be '-'.
    // The file name is assumed to not contain a script code.
    static const std::regex qmLocaleNameRegex(
        "([a-z]{2,3})([_-][A-Z]{2,3})?\\.qm$");

    std::smatch match;
    if (!std::regex_search(qmFileName, match, qmLocaleNameRegex))
        throw std::invalid_argument(
            "Invalid file name format. The expected format is xx.qm or"
            "xx_XX.qm/xx-XX.qm with a third x/X also being valid.");

    QLocale::Language language = QLocale::C;
    QLocale::Territory territory = QLocale::AnyTerritory;

    // The first match contains the complete sequence; groups can be at
    // indices >= 1.
    if (match.size() > 1)
        language = QLocale::codeToLanguage(QString::fromStdString(match[1]));
    if (match.size() > 2) {
        // There could be an empty match for the second group.
        auto t = match[2].str();
        if (t.length() > 0) {
            // This group starts with the delimiter; remove the first character.
            t.erase(t.begin());
            territory = QLocale::codeToTerritory(QString::fromStdString(t));
        }
    }

    return Tts::LocaleDescriptor(language, territory);
}

auto Tts::LocaleDescriptor::fromResourcePath(const QString &qmPath)
    -> LocaleDescriptor
{
    if (qmPath.isEmpty() || qmPath.endsWith("/"))
        return Tts::LocaleDescriptor();

    // TODO if I don't use QFile for parsing, should I handle other
    // separators than "/"?
    QString fileName = *(--qmPath.split("/").end());
    return fromFileName(fileName.toStdString());
}

bool Tts::LocaleDescriptor::operator==(const Tts::LocaleDescriptor &ld) const
{
    return language == ld.language && territory == ld.territory;
}

bool Tts::LocaleDescriptor::operator<(const Tts::LocaleDescriptor &ld) const
{
    return language < ld.language
        || (language == ld.language && territory < ld.territory);
}

std::ostream &Tts::operator<<(std::ostream &os, const Tts::LocaleDescriptor &ld)
{
    auto languageStr = QLocale::languageToString(ld.language);
    auto territoryStr = QLocale::territoryToString(ld.territory);

    return os << "(" << languageStr.toUtf8().data() << ", "
              << territoryStr.toUtf8().data() << ")";
}
